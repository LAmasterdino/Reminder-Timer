<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Intervall-Benachrichtigungen</title>
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; padding: 24px; max-width:800px; margin:auto; }
    label, select, input, button { display:block; margin:8px 0; }
    .row { display:flex; gap:8px; align-items:center; }
    .small { font-size:0.9rem; color:#555; }
    #status { margin-top:12px; padding:8px; background:#f3f3f3; border-radius:6px; }
  </style>
</head>
<body>
  <h1>Intervall-Benachrichtigungen</h1>

  <p>Wähle ein Intervall und aktiviere Benachrichtigungen. Diese Demo verwendet die Web Notifications API.
  Für persistente Push-Benachrichtigungen (wenn die Seite komplett geschlossen ist) wird ein Server benötigt.</p>

  <label>Intervall wählen
    <div class="row">
      <input id="num" type="number" min="1" value="1" style="width:80px" />
      <select id="unit">
        <option value="minutes">Minute(n)</option>
        <option value="hours">Stunde(n)</option>
        <option value="days">Tag(e)</option>
        <option value="weeks" selected>Woche(n)</option>
      </select>
      <button id="startBtn">Start</button>
      <button id="stopBtn" disabled>Stop</button>
    </div>
  </label>

  <label>
    Titel der Benachrichtigung
    <input id="title" type="text" value="Erinnerung" />
  </label>

  <label>
    Nachricht
    <input id="message" type="text" value="Das ist deine wiederkehrende Nachricht." />
  </label>

  <div id="status">
    <div><strong>Status:</strong> <span id="statustxt">Nicht gestartet</span></div>
    <div class="small">Nächste Ausführung: <span id="nextRun">—</span></div>
  </div>

  <script>
  // --- Hilfsfunktionen ---
  function msFromInterval(n, unit) {
    n = Number(n) || 1;
    switch (unit) {
      case 'minutes': return n * 60 * 1000;
      case 'hours':   return n * 60 * 60 * 1000;
      case 'days':    return n * 24 * 60 * 60 * 1000;
      case 'weeks':   return n * 7 * 24 * 60 * 60 * 1000;
      default: return n * 60 * 1000;
    }
  }

  // State
  let timerId = null;
  let nextTimeoutId = null;
  let intervalMs = null;

  // UI refs
  const startBtn = document.getElementById('startBtn');
  const stopBtn = document.getElementById('stopBtn');
  const num = document.getElementById('num');
  const unit = document.getElementById('unit');
  const statustxt = document.getElementById('statustxt');
  const nextRunEl = document.getElementById('nextRun');
  const titleInput = document.getElementById('title');
  const messageInput = document.getElementById('message');

  // --- Notification anzeigen ---
  async function showNotification(title, body) {
    if (!('Notification' in window)) {
      alert(title + '\\n\\n' + body);
      return;
    }
    if (Notification.permission !== 'granted') {
      console.warn('Notification permission not granted');
      return;
    }

    // Wenn ein Service Worker registriert ist, zeigen wir Notification über SW
    if (navigator.serviceWorker && navigator.serviceWorker.controller) {
      navigator.serviceWorker.ready.then(reg => {
        reg.showNotification(title, { body });
      }).catch(() => {
        // Fallback
        new Notification(title, { body });
      });
    } else {
      // Direkt (wenn kein SW aktiv)
      new Notification(title, { body });
    }
  }

  // --- Planen ---
  function scheduleNext(ms) {
    clearTimeout(nextTimeoutId);
    const runAt = Date.now() + ms;
    localStorage.setItem('nextRun', runAt);
    nextRunEl.textContent = new Date(runAt).toLocaleString();
    // setTimeout once, when it fires we show notification and setInterval for repeating
    nextTimeoutId = setTimeout(async () => {
      await showNotification(titleInput.value, messageInput.value);
      // danach den wiederkehrenden Timer setzen (setInterval)
      if (timerId) clearInterval(timerId);
      timerId = setInterval(() => {
        showNotification(titleInput.value, messageInput.value);
        const next = Date.now() + intervalMs;
        localStorage.setItem('nextRun', next);
        nextRunEl.textContent = new Date(next).toLocaleString();
      }, intervalMs);
      // update nextRun for the just-set interval
      const next = Date.now() + intervalMs;
      localStorage.setItem('nextRun', next);
      nextRunEl.textContent = new Date(next).toLocaleString();
    }, ms);
  }

  // --- Start/Stop Handlers ---
  async function start() {
    // Permission anfragen
    if (!('Notification' in window)) {
      alert('Dein Browser unterstützt keine Web Notifications.');
      return;
    }
    let perm = Notification.permission;
    if (perm !== 'granted') {
      perm = await Notification.requestPermission();
      if (perm !== 'granted') {
        alert('Benachrichtigungen wurden abgelehnt.');
        return;
      }
    }

    // Interval berechnen
    intervalMs = msFromInterval(num.value, unit.value);

    // schedule first run nach intervalMs (oder sofort wenn gewünscht)
    scheduleNext(intervalMs);

    // Save settings
    const cfg = {
      num: num.value, unit: unit.value,
      title: titleInput.value, message: messageInput.value,
      started: true
    };
    localStorage.setItem('notifyCfg', JSON.stringify(cfg));
    statustxt.textContent = 'Aktiv';
    startBtn.disabled = true;
    stopBtn.disabled = false;
  }

  function stop() {
    clearTimeout(nextTimeoutId);
    if (timerId) clearInterval(timerId);
    timerId = null;
    nextTimeoutId = null;
    localStorage.removeItem('notifyCfg');
    localStorage.removeItem('nextRun');
    statustxt.textContent = 'Gestoppt';
    nextRunEl.textContent = '—';
    startBtn.disabled = false;
    stopBtn.disabled = true;
  }

  // --- Register Service Worker (optional, verbessert Hintergrundverhalten) ---
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('sw.js').then(reg => {
      console.log('Service Worker registriert:', reg.scope);
    }).catch(err => {
      console.warn('SW Registrierung fehlgeschlagen:', err);
    });
  }

  // --- UI Events ---
  startBtn.addEventListener('click', start);
  stopBtn.addEventListener('click', stop);

  // Beim Laden: falls cfg vorhanden, wiederherstellen
  window.addEventListener('load', () => {
    const cfgStr = localStorage.getItem('notifyCfg');
    if (cfgStr) {
      try {
        const cfg = JSON.parse(cfgStr);
        num.value = cfg.num || num.value;
        unit.value = cfg.unit || unit.value;
        titleInput.value = cfg.title || titleInput.value;
        messageInput.value = cfg.message || messageInput.value;
        statustxt.textContent = 'Aktiv (wiederhergestellt)';
        startBtn.disabled = true;
        stopBtn.disabled = false;
        // Falls nextRun in Speicher ist, setze Timeout passend neu
        const next = Number(localStorage.getItem('nextRun')) || 0;
        if (next > Date.now()) {
          const ms = next - Date.now();
          intervalMs = msFromInterval(num.value, unit.value);
          scheduleNext(ms);
        } else {
          // Falls verpasst, plane neu ab jetzt
          intervalMs = msFromInterval(num.value, unit.value);
          scheduleNext(intervalMs);
        }
      } catch(e){ console.warn(e); }
    }
  });

  // Wenn Seite sichtbar wird, stelle sicher Timer aktiv sind
  document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'visible') {
      const cfgStr = localStorage.getItem('notifyCfg');
      if (cfgStr) {
        const next = Number(localStorage.getItem('nextRun')) || 0;
        // Wenn next in Vergangenheit liegt, plane neu
        if (next <= Date.now()) {
          intervalMs = msFromInterval(num.value, unit.value);
          scheduleNext(intervalMs);
        } else {
          // Neuzeit setzen falls nötig
          const ms = next - Date.now();
          scheduleNext(ms);
        }
      }
    }
  });

  </script>
</body>
  </html>
